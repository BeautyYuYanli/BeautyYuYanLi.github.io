<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/uploads/custom-logo.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/custom-logo.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/custom-logo.jpg">
  <link rel="mask-icon" href="/uploads/custom-logo.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"beautyyu.top","root":"/","scheme":"Gemini","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="热爱ACGN和技术的学生; 谈论音乐, 动画, 文学, 设计和自然科学">
<meta property="og:type" content="website">
<meta property="og:title" content="银河美术馆-Beautyyu">
<meta property="og:url" content="http://beautyyu.top/page/3/index.html">
<meta property="og:site_name" content="银河美术馆-Beautyyu">
<meta property="og:description" content="热爱ACGN和技术的学生; 谈论音乐, 动画, 文学, 设计和自然科学">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="BeautyYu言醴">
<meta property="article:tag" content="Beautyyu言醴">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://beautyyu.top/page/3/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>银河美术馆-Beautyyu</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="银河美术馆-Beautyyu" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">银河美术馆-Beautyyu</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Beautyyu言醴的个人独立博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-aboutme">

    <a href="/aboutme/" rel="section"><i class="fa fa-user fa-fw"></i>aboutme</a>

  </li>
        <li class="menu-item menu-item-messageboard">

    <a href="/messageboard/" rel="section"><i class="fa fa-user fa-fw"></i>messageboard</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">31</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">43</span></a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="BeautyYu言醴"
      src="/uploads/custom-logo.jpg">
  <p class="site-author-name" itemprop="name">BeautyYu言醴</p>
  <div class="site-description" itemprop="description">热爱ACGN和技术的学生; 谈论音乐, 动画, 文学, 设计和自然科学</div>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/beautyyuyanli" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;beautyyuyanli" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:beautyyuyanli@gmail.com" title="E-Mail → mailto:beautyyuyanli@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/gpRDv2nEWyWAZug" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;gpRDv2nEWyWAZug" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://t.me/water_water_water_2077" title="Telegram → https:&#x2F;&#x2F;t.me&#x2F;water_water_water_2077" rel="noopener" target="_blank"><i class="fab fa-telegram fa-fw"></i>Telegram</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>


  <div class="links-of-blogroll animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://www.weisheng.cf/" title="http:&#x2F;&#x2F;www.weisheng.cf" rel="noopener" target="_blank">微笙计协</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://qufy.me/" title="https:&#x2F;&#x2F;qufy.me" rel="noopener" target="_blank">Queensferry</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://qwq.cafe/" title="https:&#x2F;&#x2F;qwq.cafe" rel="noopener" target="_blank">hookan</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.juruoyun.top/" title="http:&#x2F;&#x2F;www.juruoyun.top" rel="noopener" target="_blank">蒟蒻云</a>
        </li>
    </ul>
  </div>

      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://beautyyu.top/2018/09/15/2018-9-15-luogu1268%E6%A0%91%E7%9A%84%E9%87%8D%E9%87%8F%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/custom-logo.jpg">
      <meta itemprop="name" content="BeautyYu言醴">
      <meta itemprop="description" content="热爱ACGN和技术的学生; 谈论音乐, 动画, 文学, 设计和自然科学">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="银河美术馆-Beautyyu">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/15/2018-9-15-luogu1268%E6%A0%91%E7%9A%84%E9%87%8D%E9%87%8F%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">luogu1268树的重量|题解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-15 00:00:00" itemprop="dateCreated datePublished" datetime="2018-09-15T00:00:00+08:00">2018-09-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文引用洛谷图床图片可能无法显示,请复制链接至新标签页查看</p>
<blockquote>
<p>树可以用来表示物种之间的进化关系。一棵“进化树”是一个带边权的树，其叶节点表示一个物种，两个叶节点之间的距离表示两个物种的差异。现在，一个重要的问题是，根据物种之间的距离，重构相应的“进化树”。</p>
<p>令N={1..n}，用一个N上的矩阵M来定义树T。其中，矩阵M满足：对于任意的i，j，k，有M[i,j] + M[j,k] &gt;= M[i,k]。树T满足：</p>
<p>1．叶节点属于集合N；</p>
<p>2．边权均为非负整数；</p>
<p>3．dT(i,j)=M[i,j]，其中dT(i,j)表示树上i到j的最短路径长度。</p>
<p>如下图，矩阵M描述了一棵树。</p>
<p><img src="https://pics1.beautyyu.top/origin.png" alt="img"> </p>
<p>树的重量是指树上所有边权之和。对于任意给出的合法矩阵M，它所能表示树的重量是惟一确定的，不可能找到两棵不同重量的树，它们都符合矩阵M。你的任务就是，根据给出的矩阵M，计算M所表示树的重量。下图是上面给出的矩阵M所能表示的一棵树，这棵树的总重量为15。</p>
<p><img src="https://pics1.beautyyu.top/origin.png" alt="img"></p>
</blockquote>
<p>非常巧妙的一道构造题.</p>
<hr>
<p>题面指出 $对于任意的i,j,k 有M[i,j] + M[j,k] \geq M[i,k]$</p>
<p>那么很显然$M$描述的是两点之间的最短路了,也就是$M[i,j]=M[i,lca(i,j)]+M[j,lca(i,j)]$</p>
<hr>
<p>我们取出一个叶子节点$a$,将它作为树根.</p>
<p>接下来我们逐个将叶子加入这颗树里.这个叶子一定会产生一个新枝,我们把这个叶子产生的枝加入答案$ans$</p>
<p>对于第二个叶子$b$,显然它只能直接和$a$连一条边,$ans=M[a,b]$</p>
<p>对于第三个叶子$c$,显然它只能加入链$[a,b]$中,根据$M$的信息我们可以算出$c$产生的枝长度$L$为$(M[a,c]+M[b,c]-M[a,b])/2$,将这个数字加入$ans$</p>
<p>对于第四个叶子$d$,事情就没有这么简单了.它有可能加入链$[a,b]$,分枝长度$L_1$;也有可能加入链$[a,c]$,分枝长度$L_2$.我们分类讨论不同情况:</p>
<ol>
<li>分支点位于$[a,lca(b,c)]$,则$L_1=L_2$</li>
<li>分支点位于$[lca(b,c),b]$,则$L_1$为$d$到$lca(b,d)$的距离;$L_2$为$d$到$lca(c,d)即lca(b,c)$的距离.显然$L_1&lt;L_2$.如果我们认为$L$为$L_2$,那么$lca(b,d)到lca(b,c)$的这一段距离就会重复计算(我们在加入$b$的时候就把这一段加入$ans$了).所以$L$为$L_1$</li>
<li>分支点位于$[lca(b,c),c]$的时候情形同上</li>
</ol>
<p>综上,对于第四个节点,$L=\min(L_1,L_2)$</p>
<p>……</p>
<p>推广到第$n$个节点,$L=\min{L_i}$</p>
<p><img src="https://pics1.beautyyu.top/origin/iaPOOI.png" alt="img"> </p>
<p><img src="https://pics1.beautyyu.top/origin/iaPjmt.png" alt="img"> </p>
<p>图片引自<a target="_blank" rel="noopener" href="https://pics1.beautyyu.top/origin-p1268">TsReaper的博客</a></p>
<hr>
<p>代码如下</p>
<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#define LL int
using namespace std;
LL map_[100][100],len[100],n;
int main()&#123;
        while (1)&#123;
                scanf(&quot;%d&quot;,&amp;n);
                if (n == 0)
                        break;
                else &#123;
                        memset(map_,0,sizeof(map_));
                        memset(len,0x3f,sizeof(len));
                        for (LL i = 1;i &lt;= n;++ i)&#123;
                                for (LL j = 1 + i;j &lt;= n;++ j)&#123;
                                        scanf(&quot;%d&quot;,&amp;map_[i][j]);
                                        map_[j][i] = map_[i][j];
                                &#125;
                        &#125;
                &#125;
                LL ans = len[2] = map_[1][2];
                for (LL i = 3;i &lt;= n;++ i)&#123;
                        for (LL j = 2;j &lt; i;++ j)&#123;
                                len[i] = min(len[i],(map_[i][j] + map_[i][1] - map_[1][j]) &gt;&gt; 1);
                        &#125;
                        ans += len[i];
                &#125;
                printf(&quot;%d\n&quot;,ans);
        &#125;

        return 0;
&#125;
</code></pre>
<p>文结</p>
<p><img src="https://pics1.beautyyu.top/origin/PKOh5D.jpg"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://beautyyu.top/2018/09/04/2018-9-04-NOI2001%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/custom-logo.jpg">
      <meta itemprop="name" content="BeautyYu言醴">
      <meta itemprop="description" content="热爱ACGN和技术的学生; 谈论音乐, 动画, 文学, 设计和自然科学">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="银河美术馆-Beautyyu">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/04/2018-9-04-NOI2001%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">NOI2001炮兵阵地|题解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-04 00:00:00" itemprop="dateCreated datePublished" datetime="2018-09-04T00:00:00+08:00">2018-09-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>司令部的将军们打算在N<em>M的网格地图上部署他们的炮兵部队。一个N</em>M的地图由N行M列组成，地图的每一格可能是山地（用“H”  表示），也可能是平原（用“P”表示），如下图。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：</p>
<p><img src="https://pics1.beautyyu.top/origin.png" alt="img"> </p>
<p>如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。   现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。</p>
</blockquote>
<p>是一道经典的状压dp题,很可惜代码丑得自己都看不下去..</p>
<p>设$f(i,S_{self},S_{father})$为考虑前i行,第i行状态为$S_{self}$,第i-1行状态为$S_{father}$时的最优解</p>
<p>设$cnt(S)$为状态$S$上放置炮兵的数量</p>
<p>转移方程为<br>$$<br>f(i,S_{self},S_{father})=max{f(i-1,S_{father},S_{grandfather})+cnt(S_{self})}<br>$$<br>按顺序枚举$S_{self},S_{father},S_{grandfather}$进行转移,枚举时应当保证三个$S$互不冲突且对于地形合法</p>
<p>注意两点:</p>
<ol>
<li>要考虑$S$可以为空集,即该行不放炮兵</li>
<li>注意滚动数组优化,否则空间不足</li>
</ol>
<p>代码如下</p>
<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;ctime&gt;
#define LL int 
using namespace std;
LL map_[200],dp[2][2000][2000],p = 0;
LL cal(LL se)&#123;
        LL cnt = 0;
        while (se)&#123;
                se -= se&amp;(-se);
                cnt ++;
        &#125;
        return cnt;
&#125;
int main()&#123;
        LL n,m;
        cin &gt;&gt; n &gt;&gt; m;
        for (LL i = 1;i &lt;= n;++ i)&#123;
                map_[i] = 0;
                for (LL j = 1;j &lt;= m;++ j)&#123;
                        char al = getchar();
                        while (al != &#39;P&#39; &amp;&amp; al != &#39;H&#39;) al = getchar();
                        map_[i] &lt;&lt;= 1;
                        if (al == &#39;P&#39;)
                                map_[i] |= 1;
                &#125;
        &#125;
        memset(dp,0,sizeof(dp));
        for (LL s = map_[1];s;s = (s - 1) &amp; map_[1])&#123;
                if (((s &lt;&lt; 1) &amp; s) || ((s &lt;&lt; 2) &amp; s))
                        continue;
                dp[0][0][s] = cal(s);
        &#125;
        for (LL k = 2;k &lt;= n;++ k)&#123;
                p = !p;
                for (LL se = map_[k];se!=-1;se = se?(se - 1) &amp; map_[k]:-1)&#123;
                        if (((se &lt;&lt; 1) &amp; se) || ((se &lt;&lt; 2) &amp; se))
                                continue;
                        LL cal_se = cal(se);
                        LL tmp = map_[k - 1]&amp;(~se);
                        for (LL fa = tmp;fa!=-1;fa = fa?(fa - 1) &amp; tmp:-1)&#123;
                                dp[p][fa][se] = 0;
                                if (((fa &lt;&lt; 1) &amp; fa) || ((fa &lt;&lt; 2) &amp; fa))
                                        continue;
                                LL tmp1 = map_[k - 2]&amp;(~fa)&amp;(~se);
                                for (LL gfa = tmp1;gfa!=-1;gfa = gfa?(gfa - 1) &amp; tmp1:-1)&#123;
                                        if (((gfa &lt;&lt; 1) &amp; gfa) || ((gfa &lt;&lt; 2) &amp; gfa))
                                                continue;
                                        dp[p][fa][se] = max(dp[p][fa][se],dp[!p][gfa][fa]+cal_se);
                                &#125;
                        &#125;
                &#125;
        &#125;
        LL ans = 0;
        for (LL se = map_[n];se!=-1;se = se?(se - 1) &amp; map_[n]:-1)&#123;
                if (((se &lt;&lt; 1) &amp; se) || ((se &lt;&lt; 2) &amp; se))
                        continue;
                LL tmp = map_[n-1]&amp;(~se);
                for (LL fa = tmp;fa != -1;fa = fa?(fa - 1) &amp; tmp:-1)&#123;
                        if (((fa &lt;&lt; 1) &amp; fa) || ((fa &lt;&lt; 2) &amp; fa))
                                continue;
                        ans = max(ans,dp[p][fa][se]);
                &#125;
        &#125;
        cout &lt;&lt; ans;

        return 0;
&#125;</code></pre>
<p>文结</p>
<p><img src="https://pics1.beautyyu.top/origin/PwLj1J.jpg"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://beautyyu.top/2018/09/04/2018-9-04-SDOI2009_SuperGCD%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/custom-logo.jpg">
      <meta itemprop="name" content="BeautyYu言醴">
      <meta itemprop="description" content="热爱ACGN和技术的学生; 谈论音乐, 动画, 文学, 设计和自然科学">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="银河美术馆-Beautyyu">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/04/2018-9-04-SDOI2009_SuperGCD%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">SDOI2009_SuperGCD|题解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-04 00:00:00" itemprop="dateCreated datePublished" datetime="2018-09-04T00:00:00+08:00">2018-09-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>一道恶心人的毒瘤题:高精度gcd</p>
<p>注意到,<strong>在高精度运算中取模是通过重复相减实现的</strong></p>
<p>所以对于高精度gcd,<strong>辗转相除法和更相减损术是一样的</strong></p>
<p>那档燃是写<strong>更相减损术</strong>啦</p>
<p>这毒瘤题还卡常,所以就搞了几个小把戏:</p>
<ol>
<li>把高精度减法直接重载为<code>-=</code></li>
<li>采取亿进制(事实上甚至可以写成万亿进制)</li>
</ol>
<p>不得不说高精度运算是很坑的算法,建议除了<code>构造函数</code>和重载<code>赋值符</code>之外所有成员函数都应该用<code>const</code>修饰</p>
<p>以及亿进制下的输出也是一个很麻烦的事情…</p>
<p>代码如下</p>
<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;ctime&gt;
#define LL long long
using namespace std;
struct big_int&#123;
        LL data[25000],len;
        big_int(char *al)&#123;
                LL al_len = strlen(al),base = 1;
                data[len = 0] = 0;
                for (LL p = al_len - 1;p &gt;= 0;p --)&#123;
                        if (base &gt;= 100000000)
                                ++ len,data[len] = 0,base = 1;
                        data[len] += (al[p] - &#39;0&#39;) * base;
                        base *= 10;
                &#125;
                len ++;
                return ;
        &#125;
        void print()const&#123;
                LL len = this-&gt;len;
                if (!len) &#123;
                        cout &lt;&lt;&quot;0\n&quot;;
                        return ;
                &#125;
                len --;
                LL b = 10000000;
                while((data[len] / b) == 0)
                        b /= 10;
                printf(&quot;%lld&quot;,data[len]);
                string out = &quot;&quot;;
                for (LL i = len - 1;i &gt;= 0;-- i)&#123;
                        LL b = 10000000,d = data[i];
                        while(b)&#123;
                                out += d / b + &#39;0&#39;;
                                d %= b;
                                b /= 10;
                        &#125;
                &#125;
                cout &lt;&lt; out &lt;&lt; endl;
                return ;
        &#125;
        bool operator &lt; (const big_int &amp;al)const&#123;
                if (len != al.len)
                        return len &lt; al.len;
                for (LL i = len - 1;i &gt;= 0;-- i)
                        if (data[i] != al.data[i])
                                return data[i] &lt; al.data[i];
                return 0;
        &#125;
        big_int operator -= (big_int &amp;al)&#123;
                for (LL i = 0;i &lt; al.len;++ i)
                        data[i] -= al.data[i];
                for (LL i = 0;i &lt; len;++ i)
                        if (data[i] &lt; 0)
                                data[i] += 100000000,
                                data[i + 1] -= 1;
                while (data[-- len] == 0 &amp;&amp; len &gt; 0);
                len ++; 
                if (len == 1 &amp;&amp; data[0] == 0)
                        len = 0;
                return *this;
        &#125;
&#125;;
LL low_gcd(LL a,LL b)&#123;
        return b?low_gcd(b,a % b):a;
&#125;
int main()&#123;
        char alpha[20000],beta[20000];
        scanf(&quot;%s%s&quot;,alpha,beta);
        if (strlen(alpha) &lt;= 18 &amp;&amp; strlen(beta) &lt;= 18)&#123;
                LL al,be;
                sscanf(alpha,&quot;%lld&quot;,&amp;al);
                sscanf(beta ,&quot;%lld&quot;,&amp;be);
                cout &lt;&lt; low_gcd(al,be);
        &#125;
        else&#123;
                big_int al = big_int(alpha),be = big_int(beta);
                while (al &lt; be || be &lt; al)&#123;
                        if (be &lt; al)
                                al -= be;
                        else
                                be -= al;
                &#125;
                al.print();
        &#125;
        return 0;
&#125;</code></pre>
<p>文结</p>
<p><img src="https://pics1.beautyyu.top/origin/PwL1yR.jpg"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://beautyyu.top/2018/08/01/2018-8-1-cf-r500-div2-d%E9%A2%98ChemicalTable%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/custom-logo.jpg">
      <meta itemprop="name" content="BeautyYu言醴">
      <meta itemprop="description" content="热爱ACGN和技术的学生; 谈论音乐, 动画, 文学, 设计和自然科学">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="银河美术馆-Beautyyu">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/01/2018-8-1-cf-r500-div2-d%E9%A2%98ChemicalTable%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">cf-r500-div2-d题ChemicalTable|题解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-01 00:00:00" itemprop="dateCreated datePublished" datetime="2018-08-01T00:00:00+08:00">2018-08-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>Innopolis University scientists continue to investigate the periodic table. There are <em>n</em>·<em>m</em> known elements and they form a periodic table: a rectangle with <em>n</em> rows and <em>m</em> columns. Each element can be described by its coordinates (<em>r</em>, <em>c</em>) (1 ≤ <em>r</em> ≤ <em>n</em>, 1 ≤ <em>c</em> ≤ <em>m</em>) in the table.</p>
<p>Recently  scientists discovered that for every four different elements in this  table that form a rectangle with sides parallel to the sides of the  table, if they have samples of three of the four elements, they can  produce a sample of the fourth element using nuclear fusion. So if we  have elements in positions (<em>r</em>1, <em>c</em>1), (<em>r</em>1, <em>c</em>2), (<em>r</em>2, <em>c</em>1), where <em>r</em>1 ≠ <em>r</em>2 and <em>c</em>1 ≠ <em>c</em>2, then we can produce element (<em>r</em>2, <em>c</em>2).</p>
<p><img src="https://pics1.beautyyu.top/origin.png" alt="img"> </p>
<p>Samples  used in fusion are not wasted and can be used again in future fusions.  Newly crafted elements also can be used in future fusions.</p>
<p>Innopolis University scientists already have samples of <em>q</em> elements. They want to obtain samples of all <em>n</em>·<em>m</em>  elements. To achieve that, they will purchase some samples from other  laboratories and then produce all remaining elements using an arbitrary  number of nuclear fusions in some order. Help them to find the minimal  number of elements they need to purchase.</p>
</blockquote>
<p>先下一个定义:</p>
<ul>
<li>联通矩阵:若有一个元素组成的集合,集合内任意一个元素都<strong>已存在</strong>或<strong>可以由同集合已存在的元素合成</strong>.显然这个集合最大时是一个(不一定连续的)矩阵形状,称<strong>联通矩阵</strong></li>
</ul>
<p>观察联通矩阵的性质</p>
<ul>
<li>若有两联通矩阵A,B.其中分别有两元素a,b.这两个元素在同一行(或同一列)时,两矩阵可以合成一个更大联通矩阵C.C的左边界为A,B左边界较小的一个,C的右边界为A,B右边界较大的一个.上下边界同理</li>
<li>若整张地图共有k个联通矩阵(当然它们两两之间无法合并),则只需添加k-1个元素就可以使整张地图联通</li>
</ul>
<p>接着逐行模拟合并联通矩阵的过程</p>
<ul>
<li>考虑前i-1行,若有一个联通矩阵A,包含$J_1,J_2,…,J_k$几个列.第i行存在任意一个元素$(i,J_t),J_t属于J$,则所有$(i,J_1),(i,J_2),…,(i,J_k)$加入矩阵A</li>
<li>考虑前i-1行,若有两个联通矩阵$A={J_{A1},J_{A2},…,J_{Ak}}$,$B={J_{B1},J_{B2},…,J_{Bk}}$,第i行存在两元素$(i,J_{At})$,$(i,J_{Bt})$,$J_{At}属于J_A,J_{Bt}属于J_B$,则将AB合并为一个矩阵</li>
<li>当然以本题规模无法存下整个矩阵.由于我们是逐行枚举的,所以只要存储矩阵中的所有列就可以代表一个<em>包含以上所有行与这些列的交点</em>的联通矩阵了</li>
<li>值得注意的是:用列来表示不会忽略空列,但是会忽略空行.因此应当加上所有空行的数量(显然在一个空行上任意添加一个元素就可以将整个行加入矩阵)</li>
<li>显然以上说的这些应该用并查集维护</li>
</ul>
<p>以下是代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> llint long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">coo</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> coo &amp;be)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x != be.x) <span class="keyword">return</span> x &lt; be.x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> y &lt; be.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;arr[<span class="number">400000</span>];</span><br><span class="line"><span class="comment">//set</span></span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">400000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == fa[k]) <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fa[k] = set_(fa[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">    fa[set_(k)] = set_(l);</span><br><span class="line">    <span class="keyword">return</span> set_(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;arr[i].x,&amp;arr[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(arr + <span class="number">1</span>,arr + <span class="number">1</span> + k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++ i)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>,cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> ifcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (++p &lt;= k &amp;&amp; arr[p].x == i)&#123;</span><br><span class="line">            ifcnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> &amp;y = arr[p].y;</span><br><span class="line">            <span class="keyword">if</span> (!f) f = set_(y);</span><br><span class="line">            <span class="keyword">else</span> merge(y,f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ifcnt) ++ cnt;</span><br><span class="line">        ifcnt = <span class="number">0</span>;</span><br><span class="line">        p --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> f = set_(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= m;++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (set_(f) != set_(i)) &#123;</span><br><span class="line">            ++ ans;</span><br><span class="line">            f = merge(f,set_(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans + cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上.</p>
<p><img src="https://pics1.beautyyu.top/origin/PKOE3d.jpg"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://beautyyu.top/2018/07/23/2018-7-23-ZJOI2005%E5%8D%88%E9%A4%90%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/custom-logo.jpg">
      <meta itemprop="name" content="BeautyYu言醴">
      <meta itemprop="description" content="热爱ACGN和技术的学生; 谈论音乐, 动画, 文学, 设计和自然科学">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="银河美术馆-Beautyyu">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/23/2018-7-23-ZJOI2005%E5%8D%88%E9%A4%90%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">ZJOI2005午餐|题解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-07-23 12:12:12" itemprop="dateCreated datePublished" datetime="2018-07-23T12:12:12+08:00">2018-07-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>上午的训练结束了，THU  ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。</p>
<p>THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。</p>
<p>现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。</p>
<p>假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。</p>
<p>现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。</p>
</blockquote>
<p>显然吃饭慢的应该先排队,满足贪心</p>
<p>可以设计状态dp(l1,l2)表示队伍长度分别为l1,l2时的最短时间</p>
<p>但是注意到两个队伍的长度是分别变化的,所以状态应当同时维护两队的进食总时间</p>
<p>转移方程见代码</p>
<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#define llint long long
using namespace std;
struct xxx&#123;
    int a,b;
    bool operator &lt; (const xxx &amp;be)const&#123;
        return b &gt; be.b;
    &#125;
&#125;arr[300];
struct yyy&#123;
    int p1,p2;
&#125;___[100000],*dp = ___ + 50000;
int main ()&#123;
    int n;
    cin &gt;&gt; n ;
    for (int i = 1;i &lt;= n;++ i)
        scanf(&quot;%d%d&quot;,&amp;arr[i].a,&amp;arr[i].b);
    sort (arr + 1,arr + 1 + n);
    for (int i = -45000;i &lt; 45000;++ i)
        dp[i].p1 = dp[i].p2 = 0x3f3f3f3f;
    dp[0] = yyy&#123;0,0&#125;;
    int sum_ = 0;
    for (int i = 1;i &lt;= n;++ i)&#123;
        sum_ += arr[i].a;
        for (int l1 = sum_;l1 &gt;= 0;-- l1)&#123;
            int l2 = sum_ - l1;
            int 
                tmp1_p1 = max(dp[l1 - arr[i].a].p1,l1 + arr[i].b),
                        tmp1_p2 = dp[l1 - arr[i].a].p2, 
                        tmp2_p1 = dp[l1].p1,
                        tmp2_p2 = max(dp[l1].p2,l2 + arr[i].b);
            if (max(tmp1_p1,tmp1_p2) &lt; max(tmp2_p1,tmp2_p2))&#123;
                dp[l1] = yyy&#123;tmp1_p1,tmp1_p2&#125;;
            &#125;
            else &#123;
                dp[l1] = yyy&#123;tmp2_p1,tmp2_p2&#125;;
            &#125;
        &#125;

    &#125;
    int ans = 0x3f3f3f3f;
    for (int i = 0;i &lt;= sum_;++ i)
        ans = min(max(dp[i].p1,dp[i].p2),ans);
    cout &lt;&lt; ans;
    return 0;
&#125;</code></pre>
<p>以上.<br><img src="https://pics1.beautyyu.top/origin/PwLhlj.jpg"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://beautyyu.top/2018/07/23/2018-7-23-AHOI2009%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/custom-logo.jpg">
      <meta itemprop="name" content="BeautyYu言醴">
      <meta itemprop="description" content="热爱ACGN和技术的学生; 谈论音乐, 动画, 文学, 设计和自然科学">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="银河美术馆-Beautyyu">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/23/2018-7-23-AHOI2009%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">AHOI2009中国象棋|题解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-07-23 00:00:00" itemprop="dateCreated datePublished" datetime="2018-07-23T00:00:00+08:00">2018-07-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>这次小可可想解决的难题和中国象棋有关，在一个N行M列的棋盘上，让你放若干个炮（可以是0个），使得没有一个炮可以攻击到另一个炮，请问有多少种放置方法。大家肯定很清楚，在中国象棋中炮的行走方式是：一个炮攻击到另一个炮，当且仅当它们在同一行或同一列中，且它们之间恰好 有一个棋子。你也来和小可可一起锻炼一下思维吧！</p>
</blockquote>
<p>由于比较弱的缘故,稍微涉及数学的题目就做了很久..</p>
<p>设计状态$dp(k,n_{1},n_{2})$为考虑前k行时,设有$n_1$列放一个炮,$n_2$列放两个炮(剩下的列不放炮)时的所有方案数</p>
<p>若在第$k$行放置$0$个炮</p>
<p>$dp(k,n_1,n_2) += dp(k-1,n_1,n_2)$</p>
<p>若在第$k$行放置$1$个炮</p>
<ol>
<li>放在只有$0$个炮的列上:$dp(k,n_1,n_2) += dp(k - 1,n_1 - 1,n_2)\times (第k-1行的n_0)$</li>
<li>放在只有$1$个炮的列上:$dp(k,n_1,n_2) += dp(k - 1,n_1 + 1,n_2 - 1)\times (第k-1行的n_1)$</li>
</ol>
<p>若在第$k$行放置$2$个炮</p>
<ol>
<li>两个炮放在只有$0$个炮的列上</li>
<li>两个炮放在只有$1$个炮的列上</li>
<li>一个炮放在有$0$个炮的列上,一个炮放在有$1$个炮的列上</li>
</ol>
<p>具体转移与约束见下代码</p>
<p>注意到复杂度为$O(nm^2)$</p>
<p>所以当$m&gt;n$时交换一下两者可能会快一些??</p>
<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#define llint long long
using namespace std;
const llint base = 9999973;
llint dp[150][150][150];
int main ()&#123;
        int n,m;
        cin &gt;&gt; n &gt;&gt; m;
        dp[0][0][0] = 1;
        for (int i = 1;i &lt;= n;++ i)&#123;
                for (int n1 = 0;n1 &lt;= m;++ n1)&#123;
                        for (int n2 = 0;n2 &lt;= m - n1;++ n2)&#123;
                                //put 0 pao 
                                dp[i][n1][n2] = dp[i - 1][n1][n2];
                                //put 1 pao
                                if(n1 &gt; 0)
                                        dp[i][n1][n2] = (dp[i - 1][n1 - 1][n2] * (m - n1 + 1 -n2) % base + dp[i][n1][n2]) % base;
                                if(n2 &gt; 0)
                                        dp[i][n1][n2] = (dp[i - 1][n1 + 1][n2 - 1] * (n1 + 1) % base + dp[i][n1][n2]) % base;
                                //put 2 pao
                                if(n1 &gt; 1)&#123;
                                        int n0_ = m - n1 + 2 - n2;
                                        dp[i][n1][n2] = ((dp[i - 1][n1 - 2][n2] * (n0_ * n0_ - n0_) / 2) % base + dp[i][n1][n2]) % base;
                                &#125;
                                if(n2 &gt; 1)&#123;
                                        int n1_ = n1 + 2;
                                        dp[i][n1][n2] = ((dp[i - 1][n1_][n2 - 2] * (n1_ * n1_ - n1_) / 2) % base + dp[i][n1][n2]) % base;
                                &#125;
                                if(n2 &gt; 0 &amp;&amp; n1 &gt; 0)&#123;
                                        int n0_ = m - n1 + 1 - n2;
                                        dp[i][n1][n2] = (dp[i - 1][n1][n2 - 1] * (n1 * n0_) % base + dp[i][n1][n2]) % base;
                                &#125;
                        &#125;
                &#125;
        &#125;
        llint ans = 0;
        for (int i = 0;i &lt;= m;++ i)
        for (int j = 0;j &lt;= m - i;++ j)
        ans = (ans + dp[n][i][j]) % base;
        cout &lt;&lt; ans;

        return 0;
&#125;</code></pre>
<p><img src="https://pics1.beautyyu.top/origin/PKOqqP.jpg"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://beautyyu.top/2018/07/20/2018-7-20-Luogu1156%E5%9E%83%E5%9C%BE%E9%99%B7%E9%98%B1%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/custom-logo.jpg">
      <meta itemprop="name" content="BeautyYu言醴">
      <meta itemprop="description" content="热爱ACGN和技术的学生; 谈论音乐, 动画, 文学, 设计和自然科学">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="银河美术馆-Beautyyu">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/20/2018-7-20-Luogu1156%E5%9E%83%E5%9C%BE%E9%99%B7%E9%98%B1%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">Luogu1156垃圾陷阱|题解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-07-20 12:12:12" itemprop="dateCreated datePublished" datetime="2018-07-20T12:12:12+08:00">2018-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>卡门――农夫约翰极其珍视的一条<code>Holsteins</code>奶牛――已经落了到“垃圾井”中。“垃圾井”是农夫们扔垃圾的地方，它的深度为 D(2≤D≤100)D(2 \le D \le 100)D(2≤D≤100) 英尺。</p>
<p>卡门想把垃圾堆起来，等到堆得与井同样高时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。</p>
<p>每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。</p>
<p>假设卡门预先知道了每个垃圾扔下的时间 t(0&lt;t≤1000)t(0&lt; t \le 1000)t(0&lt;t≤1000) ，以及每个垃圾堆放的高度 h(1≤h≤25h(1 \le h \le 25h(1≤h≤25 )和吃进该垃圾能维持生命的时间 f(1≤f≤30)f(1 \le f \le 30)f(1≤f≤30) ，要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续 101010 小时的能量，如果卡门 101010 小时内没有进食，卡门就将饿死。</p>
</blockquote>
<p>是一道经典的dp题,并没有太大的难度,但有值得注意的地方</p>
<p>题目中存在三个元素:时间,高度,生命</p>
<p>其中生命和时间都处于时间轴中,显然依照时间轴划分阶段,根据直觉应当以垃圾掉落时间划阶段</p>
<p>接着生命和高度都可以作为状态.</p>
<p>如果以生命作为状态</p>
<ol>
<li>数据范围大,导致复杂度(常数)大</li>
<li>处于时间轴中,设计转移策略时可能干扰思路</li>
<li>转移策略较复杂,且不方便枚举</li>
</ol>
<p>总之显得很不自然</p>
<p>所以应当选定高度作为状态</p>
<p>接着设计转移策略时:</p>
<ol>
<li>填表法:注意到如果高度大于D(即卡门已经得救时),难以枚举</li>
<li>刷表法:自然且方便判定死亡或得救</li>
</ol>
<p>总体上是一道考验代码能力的题目.</p>
<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#define llint long long
using namespace std;
int xx[2][200],*dp[2];
struct xxx&#123;
        int t,f,h;
        bool operator &lt; (const xxx &amp;be)const&#123;
                if (t != be.t)
                        return t &lt; be.t;
                if (f != be.t)
                        return f &gt; be.f;
                return h &gt; be.f;
        &#125;
&#125;tra[200];
int main ()&#123;
        int D,G,ans = 0x3f3f3f3f,ans2 = 0;
        cin &gt;&gt; D &gt;&gt; G;
        for (int i = 1;i &lt;= G;++ i)
                scanf(&quot;%d%d%d&quot;,&amp;tra[i].t,&amp;tra[i].f,&amp;tra[i].h);
        sort(tra + 1,tra + 1 + G);
        memset(xx,-1,sizeof(xx));
        dp[0] = xx[0];dp[1] = xx[1];
        dp[1][0] = 10;
        for (int i = 1;i &lt;= G;++ i)&#123;
                swap(dp[0],dp[1]);
                for (int j = 0;j &lt; D;++ j)&#123;
                        if (dp[0][j] &lt; tra[i].t)
                                continue;
                        if (j + tra[i].h &gt;= D) ans = min(ans,tra[i].t);
                        dp[1][j + tra[i].h] = max(dp[1][j + tra[i].h],dp[0][j]);
                        dp[1][j] = max(dp[1][j],dp[0][j] + tra[i].f);
                        ans2 = max(ans2,dp[1][j]);
                &#125;
        &#125;
        if (ans == 0x3f3f3f3f)&#123;
                cout &lt;&lt; ans2;
                return 0;
        &#125;
        cout &lt;&lt; ans;
        return 0;
&#125;</code></pre>
<p>以上.</p>
<p><img src="https://pics1.beautyyu.top/origin/PKObrt.jpg"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://beautyyu.top/2018/07/19/2018-7-19-Luogu1080%E5%9B%BD%E7%8E%8B%E6%B8%B8%E6%88%8F%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/custom-logo.jpg">
      <meta itemprop="name" content="BeautyYu言醴">
      <meta itemprop="description" content="热爱ACGN和技术的学生; 谈论音乐, 动画, 文学, 设计和自然科学">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="银河美术馆-Beautyyu">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/19/2018-7-19-Luogu1080%E5%9B%BD%E7%8E%8B%E6%B8%B8%E6%88%8F%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">Luogu1080国王游戏|题解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-07-19 00:00:00" itemprop="dateCreated datePublished" datetime="2018-07-19T00:00:00+08:00">2018-07-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>恰逢 $H$ 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n$ 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。</p>
<p>国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。</p>
</blockquote>
<p>又是一道主程序十分钟高精度一小时的题..</p>
<p>题意转化为</p>
<blockquote>
<p>每位大臣获得的金币数分别是：该大臣及前面的所有人的左手上的数的乘积除以他自己左右手上的数之和</p>
</blockquote>
<p>显然满足贪心:被除数确定时,需要让除数尽量大</p>
<p>依左右手上数之和排序即可</p>
<p>完整代码:</p>
<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#define llint long long
using namespace std;
struct bigint &#123;
        llint str[3000],len_;
        bigint operator = (llint al)&#123;
                len_ = 0;
                memset(str,0,sizeof(str));
                while (al)&#123;
                        str[len_++] = al % 10000;
                        al /= 10000;
                &#125;
                return *this;
        &#125;
        bigint operator *= (llint al)&#123;
                str[0] *= al;
                for (int i = 1;i &lt;= len_ ;i ++ )&#123;
                        str[i] = (str[i] * al) + str[i - 1] / 10000;
                        str[i - 1] %= 10000;
                &#125;
                len_ += (str[len_] &gt; 0);
                return *this;
        &#125;
        bigint operator / (llint al)&#123;
                bigint ans;
                llint handle = 0;
                for (int i = len_ - 1;i &gt;= 0;-- i)&#123;
                        handle = handle * 10000 + str[i];
                        ans.str[i] = handle / al;
                        handle %= al;
                &#125;
                ans.len_ = len_;
                while(!ans.str[ans.len_ - 1])
                        ans.len_ --;
                return ans;
        &#125;
        bool operator &lt; (const bigint &amp;al)const&#123;
                if (len_ != al.len_) return len_ &lt; al.len_;
                for (int i = len_ - 1;i &gt;= 0;--i)
                        if (str[i] != al.str[i]) return str[i] &lt; al.str[i];
                return 0;
        &#125;
        void print()&#123;
                if (!len_) &#123;
                        printf(&quot;0\n&quot;);
                        return ;
                &#125;
                printf(&quot;%lld&quot;,str[len_ - 1]);
                for (int i = len_ - 2;i &gt;= 0;--i)&#123;
                        if (str[i] &lt; 1000) putchar(&#39;0&#39;);
                        if (str[i] &lt; 100) putchar(&#39;0&#39;);
                        if (str[i] &lt; 10) putchar(&#39;0&#39;);
                        printf(&quot;%lld&quot;,str[i]);
                &#125;
                printf(&quot;\n&quot;);
        &#125;
&#125;;

struct  xxx&#123;
        llint a,b;
        bool operator &lt; (const xxx &amp;be)const&#123;
                if (a * b != be.a * be.b)
                        return a * b &lt; be.a * be.b;
                return a &lt; be.a;
        &#125;
&#125;arr[20000];

int main ()&#123;
        llint n;
        cin &gt;&gt; n;
        for (int i = 0;i &lt;= n;++ i)
                scanf(&quot;%lld%lld&quot;,&amp;arr[i].a,&amp;arr[i].b);
        bigint mul,ans;
        mul = arr[0].a,ans = (llint)0;
        sort(arr + 1,arr + 1 + n);
        for (int i = 1;i &lt;= n;++ i)
                mul *= arr[i].a,
                ans = max(ans,mul / (arr[i].a * arr[i].b));
        ans.print();
        return 0;
&#125;</code></pre>
<p>以上.</p>
<p><img src="https://pics1.beautyyu.top/origin/PKOXa8.jpg"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://beautyyu.top/2018/07/18/2018-7-18-TJOI2013%E5%A5%96%E5%AD%A6%E9%87%91%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/custom-logo.jpg">
      <meta itemprop="name" content="BeautyYu言醴">
      <meta itemprop="description" content="热爱ACGN和技术的学生; 谈论音乐, 动画, 文学, 设计和自然科学">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="银河美术馆-Beautyyu">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/18/2018-7-18-TJOI2013%E5%A5%96%E5%AD%A6%E9%87%91%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">TJOI2013奖学金|题解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-07-18 21:21:21" itemprop="dateCreated datePublished" datetime="2018-07-18T21:21:21+08:00">2018-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>小张最近发表了一篇论文,有一个神秘人物要给小张学院发奖学金。小张学院有C名学生,要从中挑出N个。这个神秘人物爱好奇特,他希望得到奖学金的同学的成绩的中位数尽可能大,但同时,他们的奖学金总额不能超过F。</p>
</blockquote>
<p>观察题目,显然应当将学生依照成绩排序</p>
<p>当成绩中位数确定时,应选取中位数两侧金额最小的学生,满足贪心原则</p>
<p>题意转化为</p>
<blockquote>
<p>求中位数两端学生中金额前<code>n/2</code>小的金额之和</p>
</blockquote>
<p>区间第k小问题,显然选用主席树解答</p>
<p>从大到小枚举中位数,选取第一个满足条件的即可</p>
<p>注意:</p>
<p>本题对空间要求严格,</p>
<ol>
<li>如果预先求出所有<code>从0开始的前缀和</code>和<code>从c开始的所有后缀和</code>的树版本,必然MLE(亲测)</li>
<li>如果只预处理前(后)缀和树,另一部分用完整树与之相减,且在枚举中位数时动态建树,可以勉强卡过(笔者的解法)</li>
<li>注意到<strong>中位数无法二分枚举</strong>,所以实际上只用到了<strong>当前版本和上一个版本的树</strong>,更早的树应当被销毁!</li>
</ol>
<p>所以当笔者写完后发现<strong>根本不需要主席树</strong>……..</p>
<p>笔者代码如下(注意数据命名与题面不符):</p>
<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#define llint long long
using namespace std;
int set_[200010],cnt[200010];
struct node&#123;
        node *lson,*rson;
        int val,sum_;
        node(int ql,int qr,bool full)&#123;
                // build a void tree
                if(ql == qr)&#123;
                        lson = rson = NULL;
                        val = full * cnt[ql];sum_ = val * set_[ql];
                &#125;
                else&#123;
                        int mid = ((qr - ql) &gt;&gt; 1) + ql;
                        lson = new node(ql,mid,full);
                        rson = new node(mid + 1,qr,full);
                        val = full * (lson-&gt;val + rson-&gt;val);
                        sum_ = full * (lson-&gt;sum_ + rson-&gt;sum_);
                &#125;
        &#125;
        node(node *ori,node *ls,node *rs,int ival)&#123;
                lson = ls;rson = rs;
                val = ori-&gt;val + 1;sum_ = ori-&gt;sum_ + set_[ival];
        &#125;
        node* insert(int ival,int l,int r)&#123;
                int mid = ((r - l) &gt;&gt; 1) + l;
                if (ival == l &amp;&amp; ival == r)
                        return new node(this,NULL,NULL,ival);
                if (ival &lt;= mid)
                        return new node(this,lson-&gt;insert(ival,l,mid),rson,ival);
                else 
                        return new node(this,lson,rson-&gt;insert(ival,mid + 1,r),ival);
        &#125;


&#125;*full,*suf[200010];
int query(node *op,int k,int l,int r)&#123;
        int mid = ((r - l) &gt;&gt; 1) + l;
        if (l == r)
                return k * set_[l];
        if (k &lt;= op-&gt;lson-&gt;val)
                return query(op-&gt;lson,k,l,mid);
        else 
                return op-&gt;lson-&gt;sum_ + query(op-&gt;rson,k - op-&gt;lson-&gt;val,mid + 1,r);
&#125;
int query2(node *op,node *ff,int k,int l,int r)&#123;
        int mid = ((r - l) &gt;&gt; 1) + l;
        if (l == r)
                return k * set_[l];
        if (k &lt;= ff-&gt;lson-&gt;val - op-&gt;lson-&gt;val)
                return query2(op-&gt;lson,ff-&gt;lson,k,l,mid);
        else 
                return ff-&gt;lson-&gt;sum_ - op-&gt;lson-&gt;sum_ + query2(op-&gt;rson,ff-&gt;rson,k -(ff-&gt;lson-&gt;val -  op-&gt;lson-&gt;val),mid + 1,r);
&#125;

struct xxx&#123;
        int score,money;
        bool operator &lt; (const xxx &amp;be)const&#123;
                return score &lt; be.score;
        &#125;
&#125;data[200010];
int main ()&#123;
//      freopen(&quot;wb.in&quot;,&quot;r&quot;,stdin);
        //readin
        int n,k,p;
        cin&gt;&gt; k &gt;&gt; n &gt;&gt; p;
        for (int i = 1;i &lt;= n;++ i)&#123;
                scanf(&quot;%d%d&quot;,&amp;data[i].score,&amp;data[i].money);
        &#125;
        sort(data + 1,data + 1 + n);
        //discrete
        for (int i = 1;i &lt;= n;++ i)
                set_[i] = data[i].money;
        sort(set_ + 1,set_ + 1 + n);
        int size_ = unique(set_ + 1,set_ + 1 + n) - set_ - 1;
        for (int i = 1;i &lt;= n;++ i)
                data[i].money = lower_bound(set_ + 1,set_ + size_ + 1,data[i].money) - set_,
                cnt[data[i].money] ++;
        //build trees
        suf[n + 1] = new node (1,size_,0);
        full = new node (1,size_,1);
        for (int i = n;i &gt; n - (k &gt;&gt; 1);-- i)
                suf[i] = suf[i + 1]-&gt;insert(data[i].money,1,size_);
        //query
        for (int i = n - (k &gt;&gt; 1);i &gt; (k &gt;&gt; 1);-- i)&#123;
                suf[i] = suf[i + 1]-&gt;insert(data[i].money,1,size_);
                if(query2(suf[i],full,k &gt;&gt; 1,1,size_) + query(suf[i + 1],k &gt;&gt; 1,1,size_) + set_[data[i].money] &lt;= p)&#123;
                        cout &lt;&lt; data[i].score;
                        return 0;
                &#125;
        &#125;
        cout &lt;&lt; -1 ;
        return 0;
&#125;</code></pre>
<p>以上.</p>
<p><img src="https://pics1.beautyyu.top/origin/PKOjIS.jpg"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BeautyYu言醴</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/local-search.js"></script>












  








  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      const script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.0/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/haru02.model.json"},"display":{"position":"right","width":275,"height":700},"mobile":{"show":false},"log":false,"tagMode":false});</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body>
</html>
